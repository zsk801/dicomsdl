Code Recipes
============

Opening a DICOM file object
---------------------------

Used functions

* :cpp:func:`dicom::open_dicomfile`
* :cpp:func:`dicom::open_dicomfile_from_memory`

Opening a DICOM file object from a file
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. highlightlang:: c++

::

	dicom::dicomfile *df;

	df = dicom::open_dicomfile("img001.dcm");
	if (!df) {
		printf("%s\n", dicom::get_error_message());
		goto __dicom_open_error__; // process error
	}

	// do something with dicomfile object

	dicom::close_dicomfile(df);
	
.. highlightlang:: python

::

	import dicom
	
	df = dicom.open_dicomfile('img001.dcm')
	if df:
		pass # Do something with dicomfile object
	else: 
		print dicom.get_error_message()

	# You don't need to close_dicomfile. If you want to remove object explicitly, use 'del'.


Opening a DICOM file object from memory buffer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. highlightlang:: c++

::

	FILE *fp;
	dicom::dicomfile *df;
	char *membuf;
	long membufsiz;
	
	fp = fopen("img001.dcm", "rb");
	if (!fp) goto __file_error__; // process error
	
	fseek(fp, 0, SEEK_END);
	membufsiz = ftell(fp);
	fseek(fp, 0, SEEK_SET);
	
	membuf = (char *)malloc(membufsiz);
	if (!membuf) goto __memory_error__; // process error 
	
	fread(membuf, 1, membufsiz, fp);
	fclose(fp);

	df = dicom::open_dicomfile_from_memory(membuf, membufsiz);
	free(membuf);
	if (!df) goto __dicom_open_error__; // process error
	
	// do something with dicomfile object
	
	dicom::close_dicomfile(df);

.. highlightlang:: python

::

	import dicom
	
	fileimage = file('img001.dcm', 'rb').read()
	df = dicom.open_dicomfile_from_memory(fileimage)
	

Get a data element and its value
--------------------------------

You have to get :cpp:class:`dicom::dicomelement` objects before accessing
values in a dicom file. A :cpp:class:`dicom::dicomelement` object can be obtained
using function :cpp:func:`dicom::dataset::get_dataelement` or
:cpp:func:`dicom::dicomfile::get_dataelement`. 

.. highlightlang:: c++

::

	dicom::dicomfile *df;
	dicom::dataelement *de;
	std::string value;
	
	// ... open dicomfile
	
	// Get a data element that holds study date (0008,0020).
	de = df->get_dataelement(0x00080020);
	
	// check existence of the data element.
	if (de->is_valid()) { 
		// retrieve value
		value = de->to_string();
	} else {
		// set value for 'non-exist' data element.
		value = std::string("N/A");
	}
	
You may shorten `get dataelement`->`check existence`->`get value` process into
one line.

.. highlightlang:: c++

::

	// to_string() will return "N/A" string if get_dataelement() returns 'invalid' or 'non-exist' dataelement.    
	value = df->get_dataelement(0x00080020)->to_string("N/A"); 
 

:cpp:func:`dicom::dicomelement::get_dataelement` takes 'tag value' in several forms.
If gggg,eeee mean group and element number of tag in hex form, following forms
are acceptable.

	* 0xggggeeee
	* "0xggggeeee"
	* "ggggeeee"
	* "ggggeeee.n.ggggeeee"
	* "KeyWord"

For example, following forms indicate a data element contains `study description`.

	* 0x00081030
	* "0x00081030"
	* "00081030"
	* "StudyDescription"

KeyWords are defined in ftp://medical.nema.org/medical/dicom/2009/09_06pu3.pdf 

Get a data element in a nested dataset
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you need to access a data element in a nested dataset, you can
use "ggggeeee.n.ggggeeee" form.
  	
.. highlightlang:: c++

::

	dicomfile *df = open_dicomfile("somefile.dcm");
	
	dataset *ds;
	dataelement *de;
	double radionuclide_dose;
	
	// get 0th dataset in the dataset sequence at (0054,0016)
	// (0054,0016) = Radiopharmaceutical Information Sequence
	ds = df->get_dataelement(0x00540016)->dataset_at(0);
	
	if (ds != NULL) {
		// (0018,1074) = RadionuclideTotalDose
		de = ds->get_dataelement(0x00181074);
		radionuclide_dose = de->to_double(0.0);
	} else {
		radionuclide_dose = 0.0;
	}
	
Above codes can be shortened using "ggggeeee.n.ggggeeee" form.

.. highlightlang:: c++

::

	radionuclide_dose = df->get_dataelement("00540016.0.00181074")->to_double(0.0);

Functions to get values
^^^^^^^^^^^^^^^^^^^^^^^

A :cpp:class:`dicom::dicomelement` objects has several functions name like
`to_variabletype()`.

.. highlightlang:: c++

::

	dicomfile *df;

	/*** get a value in 'int' form ***/
	
	int number_of_slices;
	number_of_slices = df->get_dataelement(0x00540081)->to_int(0);
	// another equivalent form
	number_of_slices = (*df)[0x00540081].to_int(0);
	// yet another equivalent form
	number_of_slices = (*df)[0x00540081];
	
	
	/*** get a value in 'real' form ***/

	double slice_thickeness
	slice_thickenss = df->get_dataelement(0x00180050)->to_double(0.0);
	siice_thickness = (*df)[0x00180050].to_double(0.0)
	slice_thickness = (*df)[0x00180050];
	
	
	/*** get multiple 'int' values in a dataelement ***/
	
	int *matrix_values;
	int n;
	(*df)["AcquisitionMatrix"].to_int_values_a(&matrix_values, &n);
	if (matrix_values != NULL) {
		printf("Acquisition Matrix");
		for (int i = 0; i < n; i++)
			printf(" %d", matrix_values[i]);
		free(matrix_values); // user SHOULD free() memories for array!
	}
	
	// similar form using std::vector
	std::vector<int> matrix_values;
	matrix_values =(*df)["AcquisitionMatrix"].to_int_values();
	// or
	matrix_values =(*df)["AcquisitionMatrix"];

	
	/*** get multiple 'double' values ***/	
	
	double *image_position;
	int n;
	(*df)["ImagePositionPatient"].to_double_values_a(&image_position, &n);
	if (image_position != NULL) {
		printf("Image Patient Positino");
		for (int i = 0; i < n; i++)
			printf(" %lf", image_position[i]);
		free(image_position); // user SHOULD free() memories for array!
	}
	
	// similar form using std::vector
	std::vector<double> image_position;
	matrix_values =(*df)["ImagePositionPatient"].to_double_values();
	// or
	matrix_values =(*df)["ImagePositionPatient"];
	
	
	/*** get string values ***/
	
	char *patient_name;
	(*df)["PatientsName"].to_string_a(&patient_name);
	if (patient_name) {
		printf("Patient name = %s\n", patient_name);
		free(patient_name); // user SHOULD free() memories for array!
	} else {
		printf("Patient name is not available\n");
	}
	
	// similar form using std::string
	std::string patient_name;
	patient_name = (*df)["PatientsName"].to_string("N/A");
	// or
	patient_name = (*df)["PatientsName"];
	
	
	/*** get a value in banary form
Setting Values
--------------


Write to File
-------------
